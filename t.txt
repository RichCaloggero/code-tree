function toHtml (tree) {
"use strict";
var $html, output, typeMap, text;

text = createText ();
typeMap = createTypeMap ();
function output (_text) {
text.append (_text);
} // output

if (! tree || !(tree instanceof Object)) {
	alert (`argument 1 to toHtml must be a valid esprima AST - must be an object - ${typeof(tree)}`);
	return ("");
} // if

process (tree);
return text.value();


function process (tree, _options) {
var options = {
separator: "",
terminator: ";\n",
keyword: "",
alt: null
}; // options
options = Object.assign (options, _options);

if (tree instanceof Array) {
tree.forEach (function (tree, index, values) {
process (tree);
if (options.separator && index < values.length-1) output (options.separator);
}); // forEach

} else {
if (tree.type && typeof(typeMap[tree.type]) === "function") {
//debug (`type: ${tree.type}`);
try {
	return typeMap[tree.type] (tree, options);
} catch (e) {
	alert(`can't execute: ${tree.type} / ${typeof(typeMap[tree.type])} / ${typeMap[tree.type] instanceof Function}`);
} // try

} else {
alert (`missing or unknown type: ${tree.type} - ${typeof(typeMap[tree.type])}`);
throw new Error ("missing type");
} // if
} // if
} // process


/// type map

function createTypeMap () {
return {};
} // createTypeMap


/// output

function createText () {
return {
text: "",
stack: [],
value: function () {return this.text;},

/*save: function () {
this.stack.push (this.text);
this.text = "";
}, // save

restore: function () {
var _text = this.text;
this.text = this.stack.pop();
return _text;
}, // restore

clear: function () {
this.text = "";
}, // clear
*/

append: function (_text) {
this.text += (_text);
//debug (`text.append: ${_text.length} ${this.text.length}`);

function escapeHtml (html) {
html = html.replace ("&", "&amp;");
html = html.replace ("<", "&lt;");
html = html.replace (">", "&gt;");
return html;
} // escapeHtml
} // append
}; // text
} // createText

} // toHtml
